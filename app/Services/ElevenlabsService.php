<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use App\Models\ElevenlabsConversation;
use App\Models\ElevenlabsAgent;
use Carbon\Carbon;
use Exception;

class ElevenlabsService
{
    protected $apiKey;
    protected $apiUrl;
    protected $apiVersion;
    protected $timeout;

    public function __construct()
    {
        $this->apiKey = config('elevenlabs.api_key');
        $this->apiUrl = config('elevenlabs.api_url');
        $this->apiVersion = config('elevenlabs.api_version', 'v1');
        $this->timeout = config('elevenlabs.timeout', 30);
    }

    /**
     * Obtener lista de conversaciones con paginaci√≥n por cursor
     * Endpoint: GET /v1/convai/conversations
     */
    public function getConversations(?int $fromTimestamp = null, ?string $cursor = null, int $pageSize = 100): array
    {
        try {
            $params = [
                'page_size' => min($pageSize, 100), // M√°ximo 100 seg√∫n la API
            ];

            // Usar call_start_after_unix seg√∫n documentaci√≥n oficial
            if ($fromTimestamp) {
                $params['call_start_after_unix'] = $fromTimestamp;
            }
            
            // Cursor para paginaci√≥n
            if ($cursor) {
                $params['cursor'] = $cursor;
            }

            $url = $this->buildUrl('/convai/conversations');
            
            Log::info('üîç Obteniendo conversaciones de Eleven Labs', [
                'url' => $url,
                'params' => $params,
                'from_timestamp' => $fromTimestamp,
                'cursor' => $cursor ? substr($cursor, 0, 20) . '...' : null,
            ]);

            $response = Http::withHeaders($this->getHeaders())
                ->withOptions(['verify' => false])
                ->timeout((int) $this->timeout)
                ->get($url, $params);
            
            $data = $response->json();
            
            Log::info('üì• Respuesta recibida', [
                'status' => $response->status(),
                'has_conversations' => isset($data['conversations']),
                'count' => count($data['conversations'] ?? []),
                'has_more' => $data['has_more'] ?? false,
            ]);

            if (!$response->successful()) {
                Log::error('‚ùå Error al obtener conversaciones', [
                    'status' => $response->status(),
                    'body' => $response->body(),
                ]);
                throw new Exception('Error al obtener conversaciones: ' . $response->status());
            }

            return $data;
        } catch (Exception $e) {
            Log::error('‚ùå Excepci√≥n al obtener conversaciones', [
                'error' => $e->getMessage(),
            ]);
            throw $e;
        }
    }

    /**
     * Obtener detalles completos de una conversaci√≥n (incluye transcript)
     * Endpoint: GET /v1/convai/conversations/{conversation_id}
     */
    public function getConversation(string $conversationId): array
    {
        try {
            $url = $this->buildUrl("/convai/conversations/{$conversationId}");
            
            Log::info('üîç Obteniendo detalles de conversaci√≥n', [
                'conversation_id' => $conversationId,
                'url' => $url,
            ]);

            $response = Http::withHeaders($this->getHeaders())
                ->withOptions(['verify' => false])
                ->timeout((int) $this->timeout)
                ->get($url);

            if (!$response->successful()) {
                Log::error('‚ùå Error al obtener conversaci√≥n', [
                    'conversation_id' => $conversationId,
                    'status' => $response->status(),
                    'body' => $response->body(),
                ]);
                throw new Exception('Error al obtener conversaci√≥n: ' . $response->status());
            }

            $data = $response->json();
            
            Log::info('‚úÖ Conversaci√≥n obtenida', [
                'conversation_id' => $conversationId,
                'has_transcript' => isset($data['transcript']),
                'message_count' => isset($data['transcript']) ? count($data['transcript']) : 0,
            ]);

            return $data;
        } catch (Exception $e) {
            Log::error('‚ùå Excepci√≥n al obtener conversaci√≥n', [
                'conversation_id' => $conversationId,
                'error' => $e->getMessage(),
            ]);
            throw $e;
        }
    }

    /**
     * Sincronizar agentes primero (para cach√© local)
     * Endpoint: GET /v1/convai/agents
     */
    public function syncAgents(): int
    {
        try {
            Log::info('üë• SINCRONIZANDO AGENTES...');
            
            $url = $this->buildUrl('/convai/agents');
            $response = Http::withHeaders($this->getHeaders())
                ->withOptions(['verify' => false])
                ->timeout((int) $this->timeout)
                ->get($url);

            if (!$response->successful()) {
                Log::error('‚ùå Error al obtener agentes', [
                    'status' => $response->status(),
                    'body' => $response->body(),
                ]);
                return 0;
            }

            $data = $response->json();
            $agents = $data['agents'] ?? [];
            
            Log::info("üìã Agentes recibidos: " . count($agents));

            $syncedCount = 0;
            foreach ($agents as $agentData) {
                $agentId = $agentData['agent_id'] ?? null;
                $name = $agentData['name'] ?? null;

                if (!$agentId || !$name) {
                    continue;
                }

                $agent = ElevenlabsAgent::updateOrCreate(
                    ['agent_id' => $agentId],
                    [
                        'name' => $name,
                        'archived' => $agentData['archived'] ?? false,
                        'last_call_time_unix_secs' => $agentData['last_call_time_unix_secs'] ?? null,
                        'metadata' => $agentData,
                    ]
                );

                $syncedCount++;
                Log::debug("  ‚úÖ Agente sincronizado: {$name} ({$agentId})");
            }

            Log::info("‚úÖ {$syncedCount} agentes sincronizados en BD local");
            return $syncedCount;

        } catch (Exception $e) {
            Log::error('‚ùå Error sincronizando agentes', [
                'error' => $e->getMessage(),
            ]);
            return 0;
        }
    }

    /**
     * Sincronizar conversaciones desde Eleven Labs (MANUAL)
     */
    public function syncConversations(?int $fromTimestamp = null, int $maxPages = 10): array
    {
        $page = 1;
        $limit = config('elevenlabs.batch_size', 100);
        $stats = [
            'total' => 0,
            'new' => 0,
            'updated' => 0,
        ];

        $fromDateStr = $fromTimestamp ? Carbon::createFromTimestamp($fromTimestamp)->format('Y-m-d H:i:s') : 'todas';

        Log::info('üöÄ INICIANDO SINCRONIZACI√ìN', [
            'from_timestamp' => $fromTimestamp,
            'from_date' => $fromDateStr,
            'max_pages' => $maxPages,
            'batch_size' => $limit,
        ]);

        // PRIMERO: Sincronizar agentes para tener el cach√© local actualizado
        $this->syncAgents();

        try {
            do {
                Log::info("üìÑ === P√ÅGINA {$page}/{$maxPages} ===");
                
                $response = $this->getConversations($page, $limit, $fromTimestamp);

                $conversations = $response['conversations'] ?? [];
                
                Log::info("üìã Conversaciones en p√°gina {$page}: " . count($conversations));

                foreach ($conversations as $index => $convData) {
                    $convId = $convData['conversation_id'] ?? 'unknown';
                    Log::info("  üìû [" . ($index + 1) . "/" . count($conversations) . "] Procesando: {$convId}");
                    
                    try {
                        $result = $this->saveConversation($convData);
                        $stats['total']++;
                        
                        if ($result['created']) {
                            $stats['new']++;
                            Log::info("    ‚úÖ NUEVA conversaci√≥n guardada");
                        } else {
                            $stats['updated']++;
                            Log::info("    üîÑ Conversaci√≥n ACTUALIZADA");
                        }
                    } catch (Exception $e) {
                        Log::error("    ‚ùå Error guardando conversaci√≥n {$convId}", [
                            'error' => $e->getMessage(),
                        ]);
                    }
                }
                
                $hasMore = $response['has_more'] ?? false;
                Log::info("üìä P√°gina {$page} completada. ¬øHay m√°s? " . ($hasMore ? 'S√ç' : 'NO'));
                Log::info("üìà Stats actuales: Total={$stats['total']}, Nuevas={$stats['new']}, Actualizadas={$stats['updated']}");
                
                $page++;

            } while ($hasMore && count($conversations) > 0 && $page <= $maxPages);

            Log::info('üéâ SINCRONIZACI√ìN COMPLETADA', $stats);
            return $stats;

        } catch (Exception $e) {
            Log::error('‚ùå ERROR FATAL EN SINCRONIZACI√ìN', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'stats' => $stats,
            ]);
            throw $e;
        }
    }

    /**
     * Guardar conversaci√≥n en BD
     */
    protected function saveConversation(array $conversationData): array
    {
        $conversationId = $conversationData['conversation_id'] ?? null;
        
        if (!$conversationId) {
            throw new Exception('conversation_id no encontrado');
        }

        Log::debug("      üîç Buscando si existe en BD: {$conversationId}");
        $conversation = ElevenlabsConversation::where('conversation_id', $conversationId)->first();
        $created = false;

        if (!$conversation) {
            $conversation = new ElevenlabsConversation();
            $created = true;
            Log::debug("      ‚ûï Nueva conversaci√≥n - ser√° creada");
        } else {
            Log::debug("      üîÑ Conversaci√≥n existente - ser√° actualizada");
        }

        // Obtener detalles completos si no tenemos la transcripci√≥n
        $fullData = $conversationData;
        if (!isset($conversationData['transcript'])) {
            Log::info("      üì• Obteniendo detalles completos con transcripci√≥n...");
            try {
                $fullData = $this->getConversation($conversationId);
            } catch (Exception $e) {
                Log::warning('      ‚ö†Ô∏è No se pudo obtener detalles completos', [
                    'conversation_id' => $conversationId,
                    'error' => $e->getMessage(),
                ]);
            }
        }

        // Mapear campos
        $conversation->conversation_id = $conversationId;
        
        // Obtener informaci√≥n del agente desde cach√© local (BD)
        $agentId = $fullData['agent_id'] ?? $conversationData['agent_id'] ?? null;
        if ($agentId) {
            $conversation->agent_id = $agentId;
            
            // Buscar nombre del agente en la tabla local (sin hacer petici√≥n a API)
            $agentName = ElevenlabsAgent::getNameByAgentId($agentId);
            if ($agentName) {
                $conversation->agent_name = $agentName;
                Log::debug("      üë§ Agente (desde BD local): {$agentName}");
            } else {
                Log::warning("      ‚ö†Ô∏è Agente {$agentId} no encontrado en BD local");
            }
        }
        
        // Fecha
        $timestamp = $fullData['metadata']['start_time_unix_secs'] ?? $conversationData['start_time_unix_secs'] ?? time();
        $conversation->conversation_date = Carbon::createFromTimestamp($timestamp);
        Log::debug("      üìÖ Fecha: {$conversation->conversation_date->format('Y-m-d H:i:s')}");
        
        // Duraci√≥n
        $conversation->duration_seconds = $fullData['metadata']['call_duration_secs'] ?? $conversationData['call_duration_secs'] ?? 0;
        Log::debug("      ‚è±Ô∏è Duraci√≥n: {$conversation->duration_seconds} segundos");
        
        // Metadata completa
        $conversation->metadata = $fullData;

        // Procesar transcripci√≥n
        $transcriptProcessed = false;
        if (isset($fullData['transcript']) && is_array($fullData['transcript'])) {
            $messageCount = count($fullData['transcript']);
            Log::info("      üí¨ Formateando transcripci√≥n con {$messageCount} mensajes");
            $conversation->transcript = $this->formatTranscript($fullData['transcript']);
            $transcriptProcessed = true;
        } elseif (isset($fullData['analysis']['transcript_summary']) && !empty($fullData['analysis']['transcript_summary'])) {
            Log::info("      üìù Usando transcript_summary del an√°lisis");
            $conversation->transcript = $fullData['analysis']['transcript_summary'];
            $transcriptProcessed = true;
        } elseif (isset($fullData['analysis']['call_summary_title']) && !empty($fullData['analysis']['call_summary_title'])) {
            Log::warning("      ‚ö†Ô∏è Usando call_summary_title (no hay transcripci√≥n completa)");
            $conversation->transcript = "Resumen: " . $fullData['analysis']['call_summary_title'];
            $transcriptProcessed = true;
        }

        if (!$transcriptProcessed) {
            Log::warning("      ‚ö†Ô∏è NO SE ENCONTR√ì TRANSCRIPCI√ìN");
        }

        $conversation->save();
        Log::info("      üíæ Conversaci√≥n guardada en BD (ID: {$conversation->id})");

        return [
            'created' => $created,
            'conversation' => $conversation,
        ];
    }

    /**
     * Formatear transcripci√≥n seg√∫n estructura real de Eleven Labs
     * Seg√∫n: https://api.elevenlabs.io/v1/convai/conversations/{conv_id}
     */
    protected function formatTranscript(array $messages): string
    {
        $transcript = '';
        
        foreach ($messages as $msg) {
            $role = $msg['role'] ?? 'unknown';
            $message = $msg['message'] ?? '';
            $time = $msg['time_in_call_secs'] ?? null;
            
            // Si el mensaje est√° vac√≠o, es probable que sea una llamada a herramienta
            if (empty($message)) {
                if (isset($msg['tool_calls']) && !empty($msg['tool_calls'])) {
                    $message = '[Llam√≥ a herramienta: ' . ($msg['tool_calls'][0]['tool_name'] ?? 'unknown') . ']';
                } elseif (isset($msg['tool_results']) && !empty($msg['tool_results'])) {
                    $message = '[Resultado de herramienta recibido]';
                } else {
                    continue; // Omitir mensajes vac√≠os sin herramientas
                }
            }
            
            // Formatear con timestamp
            if ($time !== null) {
                $minutes = floor($time / 60);
                $seconds = $time % 60;
                $timeStr = sprintf('[%02d:%02d]', $minutes, $seconds);
                $transcript .= "{$timeStr} {$role}: {$message}\n";
            } else {
                $transcript .= "{$role}: {$message}\n";
            }
        }

        return trim($transcript);
    }

    /**
     * Construir URL completa
     */
    protected function buildUrl(string $endpoint): string
    {
        $baseUrl = rtrim($this->apiUrl, '/');
        $version = $this->apiVersion;
        $endpoint = ltrim($endpoint, '/');

        return "{$baseUrl}/{$version}/{$endpoint}";
    }

    /**
     * Headers para peticiones
     */
    protected function getHeaders(): array
    {
        return [
            'Accept' => 'application/json',
            'Content-Type' => 'application/json',
            'xi-api-key' => $this->apiKey,
        ];
    }

    /**
     * Verificar conectividad
     */
    public function testConnection(): bool
    {
        try {
            $response = Http::withHeaders($this->getHeaders())
                ->withOptions(['verify' => false])
                ->timeout(10)
                ->get($this->buildUrl('/user'));

            return $response->successful();
        } catch (Exception $e) {
            Log::error('‚ùå Error al probar conexi√≥n', [
                'error' => $e->getMessage(),
            ]);
            return false;
        }
    }
}

